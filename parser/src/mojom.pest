// This is written in PEG and looks slightly different from the original
// grammar. Please consult the pest's document which describes how PEG works.
// https://pest.rs/book/grammars/peg.html

line_comment = { "//" ~ (!NEWLINE ~ ANY)* }
block_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
COMMENT = _{ line_comment | block_comment }

WHITESPACE = _{ " " | "\t" | NEWLINE }

mojom_file = {
  SOI ~ statement* ~ EOI
}

statement = {
  module_stmt |
  import_stmt |
  struct_stmt |
  union_stmt |
  interface |
  enum_stmt |
  const_stmt
}

module_stmt = { attribute_section? ~ "module" ~ identifier ~ t_semicolon }
import_stmt = { attribute_section? ~ "import" ~ string_literal ~ t_semicolon }

attribute_section = {
  "[" ~ "]" |
  "[" ~ attribute ~ ("," ~ attribute)* ~ "]"
}
attribute = { name ~ "=" ~ name | name ~ "=" ~ literal | name }

struct_stmt = { attribute_section? ~ "struct" ~ name ~ struct_body? ~ t_semicolon }
struct_body = { "{" ~ struct_item* ~ "}" }
struct_item = {
  const_stmt |
  enum_stmt |
  struct_field
}
struct_field = { attribute_section? ~ type_spec ~ name ~ ordinal_value? ~ default? ~ t_semicolon }
default = { "=" ~ constant }

union_stmt = {
  attribute_section? ~ "union" ~ name ~ "{" ~ union_field* ~ "}" ~ t_semicolon
}
union_field = { attribute_section? ~ type_spec ~ name ~ ordinal_value? ~ t_semicolon }

interface = {
  attribute_section? ~ "interface" ~ name ~ "{" ~ interface_body* ~ "}" ~ t_semicolon
}
interface_body = {
  const_stmt | enum_stmt | method_stmt
}

identifier = @{ name ~ "." ~ identifier | name }

type_spec = {
  type_name ~ "?" |
  type_name
}
type_name = { fixed_array | array | map | interface_request | basic_type_name }
basic_type_name = {
  numeric_type | handle_type | "associated" ~ identifier | identifier
}
numeric_type = {
  "bool" | "int8" | "uint8" | "int16" | "uint16" | "int32" | "uint32" |
  "int64" | "uint64" | "float" | "double"
}
handle_type = { "handle" ~ ("<" ~ specific_handle_type ~ ">")? }
specific_handle_type = {
  "message_pipe" | "shared_buffer" | "data_pipe_consumer" |
  "data_pipe_producer"
}
array = { "array" ~ "<" ~ type_spec ~ ">" }
fixed_array = { "array" ~ "<" ~ type_spec ~ "," ~ int_const_dec ~ ">" }
map = { "map" ~ "<" ~ identifier ~ "," ~ type_spec ~ ">" }
interface_request = {
  "associated" ~ identifier ~ "&" |
  identifier ~ "&"
}

const_stmt = {
  attribute_section? ~ "const" ~ type_spec ~ name ~ "=" ~ constant ~ t_semicolon
}
constant = { (literal | identifier) }

enum_stmt = { attribute_section? ~ "enum" ~ name ~ enum_block? ~ t_semicolon }
enum_block = { "{" ~ enum_value? ~ ("," ~ enum_value)* ~ ","? ~ "}" }
enum_value = {
  attribute_section? ~ name ~ "=" ~ integer |
  attribute_section? ~ name ~ "=" ~ identifier |
  attribute_section? ~ name
}

method_stmt = {
  attribute_section? ~
  name ~
  ordinal_value? ~
  parameter_list ~
  response? ~
  ";"
}
parameter_list = {
  "(" ~ ")" |
  "(" ~ parameter ~ ("," ~ parameter)* ~ ")"
}
parameter = { attribute_section? ~ type_spec ~ name ~ ordinal_value? }
response = { "=>" ~ parameter_list }

char = { ASCII_ALPHA | "_" }
name = @{ char ~ (char | ASCII_DIGIT)* }

literal = { number | "true" | "false" | "default" | string_literal }

number = @{ number_const | "+" ~ number_const | "-" ~ number_const }
number_const = @{
  "0"? ~ "." ~ ASCII_DIGIT* ~ float_exp? |
  "0" ~ ("x" | "X") ~ ASCII_HEX_DIGIT+ |
  number_part ~ ("." ~ ASCII_DIGIT*)? ~ float_exp? |
  "0"
}
number_part = @{ (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }

integer = @{ int_const | "+" ~ int_const | "-" ~ int_const }
int_const = @{ int_const_hex | int_const_dec }
int_const_dec = @{ "0" | (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
int_const_hex = @{ "0" ~ ("x" | "X") ~ ASCII_HEX_DIGIT+ }

ordinal_value = @{ "@" ~ int_const_dec }

float = @{
  ("+" | "-")? ~
  float_dec ~
  ("." ~ ASCII_DIGIT*)? ~
  float_exp?
}
float_dec = @{ "0" | (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
float_exp = @{ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+) }

string_literal = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ string_char* }
string_char = {
  !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
}

// These aren't strictly needed to parse but useful to generate meaningful
// error messages.
t_semicolon = { ";" }
